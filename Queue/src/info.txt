需求：
  1 实现1v1 ， 生产一个消费一个；     一个queue, 容量为1

  2 实现多对多， 生产一个消费一个；  一个queue，容量为1

  3 实现多对多， 生产多个消费多个； 一个queue，容量不受限制

  4 实现1v1, 发送一个回复一条；    两个queue， 容量不做要求

  5 实现多对多， 发送1条回复一条；两个queue,容量不做要求

  6 实现多对多， 发送多条回复多条；没个用户开启发送和接收两个线程， 两个queue,容量不做限制；







  解答：1 要使用queue的方式去解决问题， 简单高效， 不要使用notify和wait;
        2 使用notify和wait的例子在模块Queue里面（不要考虑这种方式）
              问题： 1. 即使可以实现也是复杂，而且扩展性差，相当于在工作线程里实现了一个queue;
                     2. 必须通过同步的方式保证send()、notify()和wait()原子运行；
                     3. queue使用while和wait解决上面的同步问题；
        3 发送接收发送这种模式原理：
            a. 使用了单个线程完成发送和接收；
            b. 接收控制着发送， 接收之后才会发送；
            c. 一方的发送会触发另一方的接收；反之亦是如此；
            d. 一方一个用于接收消息的queue和一个发送消息的queue, 交叉使用；



关于api调用：
   判断并清除当前  Thread.interrupted();
   判断  client.isInterrupted();
   中断  client.interrupt();